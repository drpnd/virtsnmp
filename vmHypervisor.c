/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf 17798 2009-10-27 06:44:54Z magfr $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "globalHandler.h"
#include "vmHypervisor.h"

/** Initializes the hypervisor module */
void
init_vmHypervisor(void)
{
    const oid vmHvSoftware_oid[] = { 1,3,6,1,2,1,VM_MIB_OID,1,1,1 };
    const oid vmHvVersion_oid[] = { 1,3,6,1,2,1,VM_MIB_OID,1,1,2 };
    const oid vmHvObjectID_oid[] = { 1,3,6,1,2,1,VM_MIB_OID,1,1,3 };
    const oid vmHvUpTime_oid[] = { 1,3,6,1,2,1,VM_MIB_OID,1,1,4 };

    DEBUGMSGTL(("vmHypervisor", "Initializing\n"));

    netsnmp_register_instance(
        netsnmp_create_handler_registration("vmHvSoftware",
                                            handle_vmHvSoftware,
                                            vmHvSoftware_oid,
                                            OID_LENGTH(vmHvSoftware_oid),
                                            HANDLER_CAN_RONLY
            ));
    netsnmp_register_instance(
        netsnmp_create_handler_registration("vmHvVersion",
                                            handle_vmHvVersion,
                                            vmHvVersion_oid,
                                            OID_LENGTH(vmHvVersion_oid),
                                            HANDLER_CAN_RONLY
            ));
    netsnmp_register_instance(
        netsnmp_create_handler_registration("vmHvObjectID",
                                            handle_vmHvObjectID,
                                            vmHvObjectID_oid,
                                            OID_LENGTH(vmHvObjectID_oid),
                                            HANDLER_CAN_RONLY
            ));
    netsnmp_register_instance(
        netsnmp_create_handler_registration("vmHvUpTime",
                                            handle_vmHvUpTime,
                                            vmHvUpTime_oid,
                                            OID_LENGTH(vmHvUpTime_oid),
                                            HANDLER_CAN_RONLY
            ));
}

int
handle_vmHvSoftware(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    char *str;
    size_t len;

    switch ( reqinfo->mode ) {
        case MODE_GET:
            /* Get hypervisor software */
            str = gh_getHvSoftware();
            if ( NULL == str ) {
                return SNMP_ERR_GENERR;
            }
            len = strlen(str);
            /* SnmpAdminString = ASN_OCTET_STR */
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     (u_char *)str, len);
            free(str);

            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_vmHvSoftware\n",
                     reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_vmHvVersion(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    char *str;
    size_t len;

    switch ( reqinfo->mode ) {

        case MODE_GET:
            /* Get hypervisor version */
            str = gh_getHvVersion();
            if ( NULL == str ) {
                return SNMP_ERR_GENERR;
            }
            len = strlen(str);
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     (u_char *)str, len);
            free(str);

            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_vmHvVersion\n",
                     reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_vmHvObjectID(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    oid oidvar[] = { 0, 0 };

    switch ( reqinfo->mode ) {

        case MODE_GET:
            /* We don't have vendor specific objects */
            snmp_set_var_typed_value(requests->requestvb, ASN_OBJECT_ID,
                                     (u_char *)oidvar, sizeof(oidvar));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_vmHvObjectID\n",
                     reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_vmHvUpTime(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    u_long timeticks;

    /* netsnmp_get_agent_uptime?? */

    switch ( reqinfo->mode ) {

        case MODE_GET:
            timeticks = gh_getHvUpTime();
            snmp_set_var_typed_value(requests->requestvb, ASN_TIMETICKS,
                                     (u_char *)&timeticks,
                                     sizeof(u_long));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_vmHvUpTime\n",
                     reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
